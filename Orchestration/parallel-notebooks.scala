{"version":"NotebookV1","origId":3406443095179068,"name":"parallel-notebooks","language":"scala","commands":[{"version":"CommandV1","origId":3406443095179069,"guid":"e11c214e-aa51-410b-8a3b-69e07d22b5f1","subtype":"command","commandType":"auto","position":1.0,"command":"import scala.concurrent.{Future, Await}\nimport scala.concurrent.duration._\nimport scala.util.control.NonFatal","commandVersion":1,"state":"finished","results":{"type":"raw","data":"","arguments":{}},"errorSummary":null,"error":null,"workflows":[],"startTime":0,"submitTime":0,"finishTime":0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","latestUserId":null,"commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"datasetPreviewNameToCmdIdMap":{},"nuid":"0353ba48-7308-4d93-b973-5876a8037992"},{"version":"CommandV1","origId":3406443095179070,"guid":"01c459c7-2a3c-48ec-87a3-94c4ec786190","subtype":"command","commandType":"auto","position":2.0,"command":"case class NotebookData(path: String, timeout: Int, parameters: Map[String, String] = Map.empty[String, String])\n\ndef parallelNotebooks(notebooks: Seq[NotebookData]): Future[Seq[String]] = {\n  import scala.concurrent.{Future, blocking, Await}\n  import java.util.concurrent.Executors\n  import scala.concurrent.ExecutionContext\n  import com.databricks.WorkflowException\n\n  val numNotebooksInParallel = 4 \n  // If you create too many notebooks in parallel the driver may crash when you submit all of the jobs at once. \n  // This code limits the number of parallel notebooks.\n  implicit val ec = ExecutionContext.fromExecutor(Executors.newFixedThreadPool(numNotebooksInParallel))\n  val ctx = dbutils.notebook.getContext()\n  \n  Future.sequence(\n    notebooks.map { notebook => \n      Future {\n        dbutils.notebook.setContext(ctx)\n        if (notebook.parameters.nonEmpty)\n          dbutils.notebook.run(notebook.path, notebook.timeout, notebook.parameters)\n        else\n          dbutils.notebook.run(notebook.path, notebook.timeout)\n      }\n      .recover {\n        case NonFatal(e) => s\"ERROR: ${e.getMessage}\"\n      }\n    }\n  )\n}\n\ndef parallelNotebook(notebook: NotebookData): Future[String] = {\n  import scala.concurrent.{Future, blocking, Await}\n  import java.util.concurrent.Executors\n  import scala.concurrent.ExecutionContext.Implicits.global\n  import com.databricks.WorkflowException\n\n  val ctx = dbutils.notebook.getContext()\n  // The simplest interface we can have but doesn't\n  // have protection for submitting to many notebooks in parallel at once\n  Future {\n    dbutils.notebook.setContext(ctx)\n    \n    if (notebook.parameters.nonEmpty)\n      dbutils.notebook.run(notebook.path, notebook.timeout, notebook.parameters)\n    else\n      dbutils.notebook.run(notebook.path, notebook.timeout)\n    \n  }\n  .recover {\n    case NonFatal(e) => s\"ERROR: ${e.getMessage}\"\n  }\n}\n","commandVersion":0,"state":"finished","results":null,"errorSummary":null,"error":null,"workflows":[],"startTime":0,"submitTime":0,"finishTime":0,"collapsed":false,"bindings":{},"inputWidgets":{},"displayType":"table","width":"auto","height":"auto","xColumns":null,"yColumns":null,"pivotColumns":null,"pivotAggregation":null,"customPlotOptions":{},"commentThread":[],"commentsVisible":false,"parentHierarchy":[],"diffInserts":[],"diffDeletes":[],"globalVars":{},"latestUser":"","latestUserId":null,"commandTitle":"","showCommandTitle":false,"hideCommandCode":false,"hideCommandResult":false,"iPythonMetadata":null,"streamStates":{},"datasetPreviewNameToCmdIdMap":{},"nuid":"aaa96470-1ac4-4ba9-af1d-703ed66d65ce"}],"dashboards":[],"guid":"74466bbe-0028-49e8-a916-0c24a6a500a0","globalVars":{},"iPythonMetadata":null,"inputWidgets":{}}